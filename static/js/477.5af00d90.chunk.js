"use strict";(self.webpackChunkdsim=self.webpackChunkdsim||[]).push([[477],{2389:function(e,t,n){var a=n(5671),r=n(3144),s=function(){function e(t){(0,a.Z)(this,e),this.ac=void 0,this.level=void 0,this.pb=void 0,this.sm=void 0,this.critStack=void 0,this.funcReg=void 0,this.varReg=void 0,this.ac=t.ac,this.sm=t.sm,this.pb=t.pb,this.level=t.level,this.varReg=new Map,this.funcReg=new Map,this.critStack=[]}return(0,r.Z)(e,[{key:"crit",value:function(){return!!this.critStack[this.critStack.length-1]}},{key:"popCrit",value:function(){this.critStack.pop()}},{key:"pushCrit",value:function(e){this.critStack.push(e)}},{key:"reset",value:function(){this.critStack.length=0,this.funcReg.clear(),this.varReg.clear()}}]),e}();t.Z=s},2393:function(e,t,n){n.d(t,{Z:function(){return u}});var a=n(7762),r=n(5671),s=n(3144),i=n(7757),o=n.n(i),u=function(){function e(t,n,a,s,i){(0,r.Z)(this,e),this.typeName=void 0,this.rawExpression=void 0,this.subExpressions=void 0,this.evalFunc=void 0,this.props=void 0,this.typeName=t,this.rawExpression=n,this.subExpressions=a,this.evalFunc=s,this.props=i}return(0,s.Z)(e,[{key:"eval",value:function(e){return this.evalFunc(e,this)}},{key:"iterateExpression",value:o().mark((function e(){var t,n,r;return o().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this;case 2:t=(0,a.Z)(this.subExpressions),e.prev=3,t.s();case 5:if((n=t.n()).done){e.next=10;break}return r=n.value,e.delegateYield(r.iterateExpression(),"t0",8);case 8:e.next=5;break;case 10:e.next=15;break;case 12:e.prev=12,e.t1=e.catch(3),t.e(e.t1);case 15:return e.prev=15,t.f(),e.finish(15);case 18:case"end":return e.stop()}}),e,this,[[3,12,15,18]])}))}]),e}()},1970:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(5671),r=n(3144),s=n(2393),i=function(){function e(t){(0,a.Z)(this,e),this.typeName=void 0,this.regex=void 0,this.globalRegex=void 0,this.parseFunc=void 0,this.evalFunc=void 0,this.numOperands=void 0,this.sample=void 0,this.description=void 0,this.typeName=t.typeName,this.regex=t.regex;var n=t.regex.flags?"".concat(t.regex.flags,"g"):"g";this.globalRegex=new RegExp(t.regex.source,n),this.parseFunc=t.parseFunc,this.evalFunc=t.evalFunc,this.numOperands=t.numOperands||0,this.sample=t.sample,this.description=t.description}return(0,r.Z)(e,[{key:"create",value:function(e,t,n){if(this.numOperands&&t.length!==this.numOperands)throw Error('Invalid syntax in "'.concat(e,'": ').concat(this.typeName," expected ").concat(this.numOperands," operands but got ").concat(t.length));var a=this.parseFunc(n,t);return new s.Z(this.typeName,e,t,this.evalFunc,a)}}]),e}()},7765:function(e,t,n){var a=Math.random,r={NoPF:function(){return{}},sum:function(e){return e.reduce((function(e,t){return e+t}),0)},roll:function(e){return Math.floor(a()*e)+1}};t.Z=r},3333:function(e,t,n){n.d(t,{q:function(){return p}});var a,r=n(3433),s=n(4873),i=n(1970),o=n(7765),u=o.Z.NoPF,l=o.Z.sum,h=o.Z.roll;function c(e,t,n,a,r,s){return new i.Z({typeName:e,regex:n,numOperands:2,parseFunc:a,evalFunc:r,description:s,sample:t})}!function(e){e.Discard="Discard",e.Assign="Assign",e.AssignAndEvaluate="Assign (and Evaluate)",e.Check="Check",e.Attack="Attack",e.Save="Save",e.Or="Or",e.And="And",e.GreaterThanOrEqualTo="Greater Than Or Equal To",e.GreaterThan="Greater Than",e.LessThanOrEqualTo="Less Than Or Equal To",e.LessThan="Less Than",e.NotEqualTo="Not Equal To",e.EqualTo="Equal To",e.Add="Add",e.Subtract="Subtract",e.Multiply="Multiply",e.Divide="Divide",e.Repeat="Repeat",e.RerollIfLessThanOrEqualTo="Reroll (If Less Than Or Equal To)"}(a||(a={}));var d=function(e,t){if(!t.includes(e.typeName))throw Error('Type of "'.concat(e.rawExpression,'" was expected to be one of "').concat(t,'", but was "').concat(e.typeName,'"'));return e.typeName},p=[c(a.Discard,";",/;/,u,(function(e,t){return t.subExpressions[0].eval(e),t.subExpressions[1].eval(e)}),"The result of the left operand is discarded (though is still evaluated, so variables and functions will be assigned); output is the result of the right operand. Can be useful after assignment when the assigned value should not be immediately added."),c(a.Assign,":=",/:=/,(function(e,t){return{storedType:d(t[0],["Variable","Function"])}}),(function(e,t){if("Function"===t.props.storedType){var n,a=null===(n=t.subExpressions[0].props)||void 0===n?void 0:n.funcName;e.funcReg.set(a,t.subExpressions[1])}else if("Variable"===t.props.storedType){var r,s=null===(r=t.subExpressions[0].props)||void 0===r?void 0:r.varName,i=t.subExpressions[1].eval(e);e.varReg.set(s,i)}return 0}),'Assign value to variable or sub expression to function. Output is 0.\n\nFor example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. This can be useful in cases where you need to know the outcome of an earlier attack, such as whether you\'ve already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6))\n\nCan also assign a sub expression as a function:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each time it is used later, it will be re-evaluated (dice will be rolled again):\n  (@a := 1D6+3); (3+PB =atk> @a) + (5+PB =atk> @a)\n\nThese can be combined to useful effect; for example, effects that can only\nhappen once per turn, but have multiple opportunities to happen, like sneak attack:\n  @sa := !$sd => ($sd=1D6); (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @sa)\nThe above defines a function "@sa" (sneak attack) that will roll 1D6, and assign the result to "$sd" (sneak damage); but only if "$sd" is a not ("!") zero (i.e. has already been rolled). The ";" separates it from the rest of the expression. Then "@sd" can be inserted anywhere the sneak attack could occur (on any attack hit). Note that this method will mean that the sneak attack always occurs on the first attack that hits.'),c(a.AssignAndEvaluate,"=",/(?<![=<>!:&|])=(?![=>a-zA-Z])/,(function(e,t){return{storedType:d(t[0],["Variable","Function"])}}),(function(e,t){if("Function"===t.props.storedType){var n,a,r=null===(n=t.subExpressions[0].props)||void 0===n?void 0:n.funcName;return e.funcReg.set(r,t.subExpressions[1]),(null===(a=e.funcReg.get(r))||void 0===a?void 0:a.eval(e))||0}if("Variable"===t.props.storedType){var s,i=null===(s=t.subExpressions[0].props)||void 0===s?void 0:s.varName,o=t.subExpressions[1].eval(e);return e.varReg.set(i,o),o}return 0}),'Assign value to variable or sub expression to function. Output is the result of evaluating the assigned expression. This is the same as ":=", except for the output. NOTE this means that any assigned function will be evaluatedimmediately, and any variables changed as part of the function will be changed when it is immediately evaluated!'),c(a.Check,"=>",/=>/,u,(function(e,t){return t.subExpressions[0].eval(e)?t.subExpressions[1].eval(e):0}),"If left operand is non-zero, then output the right operand, otherwise output 0. For example:\n  (1d20 <= 11) => 1d8"),c(a.Attack,"=atk>",/=atk(?::(\d+))?(?::(adv|dis)(\d+)?)?>/,(function(e){return{critmin:Number(e[1]||20),vantage:(t=e[2],n=e[3],"adv"===t?Number(n||2):"dis"===t?-Number(n||2):0)};var t,n}),(function(e,t){var n=t.props,a=t.subExpressions,i=h(20);if(n.vantage>1||n.vantage<-1){var o=(0,s.w)(Math.abs(n.vantage)-1).map((function(){return h(20)}));i=(n.vantage>0?Math.max:Math.min).apply(void 0,[i].concat((0,r.Z)(o)))}var u=1===i,l=i>=n.critmin;if(!u&&(l||a[0].eval(e)+i>=e.ac)){e.pushCrit(l);var c=a[1].eval(e);return e.popCrit(),c}return 0}),"Make an attack. The left operand will be added to the d20 roll, and if the result meets the AC then the output is the right operand. For example:\n  3+PB =atk> 1D6+3\nThe above is mostly equivalent to:\n  (3+PB + 1d20 >= AC) => 1D6+3\nHowever, the =atk> operator also accounts for crits. If the d20 rolled for the attack is a 1, then the attack will miss regardless of modifiers and AC. If the d20 rolled for the attack is a 20, then the critical hit flag is set (the number of dice rolled in the 1D6 damage roll will then be doubled; note that the doubling of dice only applies when the uppercase D is used; using a lowercase d will not double dice).\n\nCan also specify that the attack be made with advantage or disadvantage:\n  3+PB =atk:adv> 1D6+3\n  3+PB =atk:dis> 1D6+3\nOr even super advantage or disadvantage:\n  3+PB =atk:adv3> 1D6+3\n  3+PB =atk:dis3> 1D6+3\n\nCan also specify the minimum critical hit threshold, for example if you can crit on a 19:\n  3+PB =atk:19> 1D6+3\n\nNote that if you specify both adv/dis and crit threshold, the crit threshold should come first:\n3+PB =atk:19:dis> 1D6+3"),c(a.Save,"=sav>",/=sav:(\d+)(?::(adv|dis))?>/,(function(e){var t;return{successmod:Number(null!==(t=e[1])&&void 0!==t?t:50)/100,vantage:e[2]}}),(function(e,t){var n=h(20);"adv"===t.props.vantage?n=Math.max(n,h(20)):"dis"===t.props.vantage&&(n=Math.min(n,h(20)));var a=t.subExpressions[1].eval(e);return n+e.sm>=t.subExpressions[0].eval(e)?Math.floor(a*t.props.successmod):a}),"Have the target make a saving throw. The left operand is the difficulty class (DC) of the save; if the target save (1d20 + SM) does not meet the DC, then the output will be the right operand. Otherwise, if the target save does meet the DC, then the output will be half the right operand. For example:\n  8+3+PB =sav> 3d8\nThe above is equivalent to:\n  ($s := 1d20 + SM) + ($s < 8+3+PB => 3d8) + ($s >= 8+3+PB => 3d8/2)\n\nCan also specify that the save be made with advantage or disadvantage:\n  8+3+PB =sav:adv> 3d8\n  8+3+PB =sav:dis> 3d8\n\nCan also specify the output modifier for save success, for example if suceeding on the save results in no damage being taken:\n  8+3+PB =sav:0> 3d8\nNote the the success modifier is specified as a positive integer percentage, so a value of 25 would mean that the damage is quartered.\n\nNote that if you specify both adv/dis and success modifier, the success modifier should come first:\n  8+3+PB =sav:0:adv> 3d8"),c(a.Or,"||",/\|\|/,u,(function(e,t){return t.subExpressions[0].eval(e)||t.subExpressions[1].eval(e)}),"Outputs the second operand if the first is 0, otherwise outputs the first operand."),c(a.And,"&&",/&&/,u,(function(e,t){return t.subExpressions[0].eval(e)&&t.subExpressions[1].eval(e)}),"Outputs the second operand if the first is non-zero, otherwise outputs 0"),c(a.GreaterThanOrEqualTo,">=",/>=/,u,(function(e,t){return Number(t.subExpressions[0].eval(e)>=t.subExpressions[1].eval(e))}),"Outputs 1 if the left operand is greater than or equal to the right operand, otherwise 0."),c(a.GreaterThan,">",/(?<!=)>(?!=)/,u,(function(e,t){return Number(t.subExpressions[0].eval(e)>t.subExpressions[1].eval(e))}),"Outputs 1 if the left operand is greater than the right operand, otherwise 0."),c(a.LessThanOrEqualTo,"<=",/<=/,u,(function(e,t){return Number(t.subExpressions[0].eval(e)<=t.subExpressions[1].eval(e))}),"Outputs 1 if the left operand is less than or equal to the right operand, otherwise 0."),c(a.LessThan,"<",/(?<!=)<(?!=)/,u,(function(e,t){return Number(t.subExpressions[0].eval(e)<t.subExpressions[1].eval(e))}),"Outputs 1 if the left operand is less than the right operand, otherwise 0."),c(a.NotEqualTo,"!=",/!=(?!>)/,u,(function(e,t){return Number(t.subExpressions[0].eval(e)!==t.subExpressions[1].eval(e))}),"Outputs 1 if the left operand is not equal to the right operand, otherwise 0."),c(a.EqualTo,"==",/==(?!>)/,u,(function(e,t){return Number(t.subExpressions[0].eval(e)===t.subExpressions[1].eval(e))}),"Outputs 1 if the left operand is equal to the right operand, otherwise 0."),c(a.Add,"+",/\+/,u,(function(e,t){return l(t.subExpressions.map((function(t){return t.eval(e)})))}),"Outputs the sum of the left operand and right operand"),c(a.Subtract,"-",/(?<![-+*/=><|&])-(?!>)/,u,(function(e,t){return t.subExpressions[0].eval(e)-l(t.subExpressions.slice(1).map((function(t){return t.eval(e)})))}),"Outputs the result of subtracting the right operand from the left operand."),c(a.Multiply,"*",/\*/,u,(function(e,t){return t.subExpressions.reduce((function(t,n){return t*n.eval(e)}),1)}),"Outputs the result of multiplying the left operand by the right operand."),c(a.Divide,"/",/\//,u,(function(e,t){return Math.floor(t.subExpressions[0].eval(e)/t.subExpressions[1].eval(e))}),"Outputs the result of dividing the left operand by the right operand. Decimal results are rounded down the nearest whole integer."),c(a.Repeat,"#",/#/,u,(function(e,t){var n=Number(t.subExpressions[0].eval(e));if(n<0)throw new Error("Cannot repeat a negative (".concat(n,") number of times: ").concat(t.rawExpression));return l((0,r.Z)(new Array(n)).map((function(){return t.subExpressions[1].eval(e)})))}),"Outputs the sum of repeating evaluation of the right operand a number of times equal to the left operand. Left operand must be a positive integer."),c(a.RerollIfLessThanOrEqualTo,"@rrlte:",/@rrlte:/,(function(){throw new Error("@rrlte: has been removed; use the 2d6rrle2 syntax instead")}),(function(){throw new Error("@rrlte: has been removed; use the 2d6rrle2 syntax instead")}),"")]},2959:function(e,t,n){n.d(t,{A:function(){return i}});var a=n(1970),r=n(7765).Z.NoPF;function s(e,t,n,r,s,i){return new a.Z({typeName:e,regex:n,numOperands:1,parseFunc:r,evalFunc:s,description:i,sample:t})}var i=[s("Not","!",/^!/,r,(function(e,t){return t.subExpressions[0].eval(e)?0:1}),"Outputs 0 if the right operand is non-zero, otherwise outputs 1."),s("Negative","-",/^-/,r,(function(e,t){return-1*t.subExpressions[0].eval(e)}),"Flips the sign of the right operand (multiply by -1).")]},8118:function(e,t,n){n.d(t,{Q:function(){return p}});var a,r=n(3433),s=n(1970),i=n(7765),o=i.Z.NoPF,u=i.Z.sum,l=i.Z.roll;function h(e,t,n,a,r,i){return new s.Z({typeName:e,regex:n,parseFunc:a,evalFunc:r,description:i,sample:t})}!function(e){e.Number="Number",e.RollDice="Roll Dice",e.ArmorClass="Armor Class",e.SaveModifier="Save Modifier",e.ProficiencyBonus="Proficiency Bonus",e.Level="Level",e.CriticalMultiplier="Critical Multiplier",e.CriticalBinary="Critical Binary",e.Variable="Variable",e.Function="Function"}(a||(a={}));var c={kh:function(e,t){return e.sort((function(e,t){return t-e})).slice(0,t)},kl:function(e,t){return e.sort((function(e,t){return e-t})).slice(0,t)},rrle:function(e,t,n){return e.forEach((function(e,a,r){e<=t&&(r[a]=l(n))}))},rrlt:function(e,t,n){return e.forEach((function(e,a,r){e<t&&(r[a]=l(n))}))},rrge:function(e,t,n){return e.forEach((function(e,a,r){e>=t&&(r[a]=l(n))}))},rrgt:function(e,t,n){return e.forEach((function(e,a,r){e>t&&(r[a]=l(n))}))},rreq:function(e,t,n){return e.forEach((function(e,a,r){e===t&&(r[a]=l(n))}))}},d=Object.keys(c).join("|"),p=[h(a.Number,"X",/^\d+$/,(function(e){return{value:Number(e[0])}}),(function(e,t){return t.props.value}),"Where X is any positive integer. Outputs the value of the integer."),h(a.RollDice,"XdY",new RegExp("^(\\d*)([dD])(\\d+)((?:(?:".concat(d,")\\d+)*)$")),(function(e){return{crittable:"D"===e[2],dieSize:Number(e[3]),numDice:Number(e[1]||1),operations:(0,r.Z)(e[4].matchAll(/([a-zA-Z]+)(\d+)/g)).map((function(e){return{operation:e[1],param:Number(e[2])}}))}}),(function(e,t){for(var n=t.props,a=n.crittable,r=n.dieSize,s=n.numDice,i=n.operations,o=[],h=a&&e.crit()?2*s:s,d=0;d<h;d+=1)o.push(l(r));return i.forEach((function(e){var t=e.operation,n=e.param;o=c[t](o,n,r)||o})),u(o)}),'Where X and Y are any positive integers. Outputs the sum of rolls with a dice of size Y rolled X number of times. For example:\n  3d8\nIn the above, an 8 sided dice will be rolled 3 times, and the output will be the sum of the results.\n\nCritical hits can be accounted for with an uppercase D to double the number of dice rolled on a critical hit:\n  3D8\nIn the above, if the critical hit flag is set  (in the right operand of an Attack where the attack roll was >= to the critical threshold), then an 8 sided dice will be rolled 6 times.\n\nCan also append additional modifier operations after the above basic rolls, such as "keep highest":\n  3d8kh2\nThe above rolls 3 d8s, and keeps the two highest rolls. To simulate the "Great Weapon Fighting Style" you could instead use rrle:\n  2D6rrle2\nWhich rolls 2 d6s (or 4 on a crit), and rerolls any 1s and 2s. Any number of these operations can be appended, such as:\n  4d6kl2rrle2kh1\nWhich rolls 4 d6s, then keeps the lowest 2, then rerolls any of the remaining 2 that are 2 or less, then keeps the highest 1 of those remaining 2.\n\nThe available modifier operations (where X is any positive integer) are:\n  khX: Keep the highest X dice\n  klX: Keep the lowest X dice\n  rrleX: Reroll (only once) any dice that are less than or equal to X\n  rrltX: Reroll (only once) any dice that are less than X\n  rrgeX: Reroll (only once) any dice that are greater than or equal to X\n  rrgtX: Reroll (only once) any dice that are greater than X\n  rreqX: Reroll (only once) any dice that are equal to X\n'),h(a.ArmorClass,"AC",/^AC$/,o,(function(e,t){return e.ac}),"Outputs the armor class of the target the simulation is being run against."),h(a.SaveModifier,"SM",/^SM$/,o,(function(e,t){return e.ac}),"Outputs the save modifier of the target the simulation is being run against."),h(a.ProficiencyBonus,"PB",/^PB$/,o,(function(e,t){return e.pb}),"Outputs the proficiency bonus for the level of the character build."),h(a.Level,"LV",/^LV$/,o,(function(e,t){return e.level}),"Outputs the level of the character build."),h(a.CriticalMultiplier,"CM",/^CM$/,o,(function(e,t){return 1*Number(e.crit())+1}),"Outputs 2 if critical flag is set (in the right operand of an Attack where   the attack roll was >= to the critical threshold), otherwise 1."),h(a.CriticalBinary,"CB",/^CB$/,o,(function(e,t){return 1*Number(e.crit())}),"Outputs 1 if critical flag is set (in the right operand of an Attack where the attack roll was >= to the critical threshold), otherwise 0."),h(a.Variable,"$X",/^\$([a-zA-Z0-9]+)$/,(function(e){return{varName:e[1]}}),(function(e,t){return e.varReg.get(t.props.varName)||0}),"Where X is a string of alphanumeric characters. A variable that can be stored and retrieved. Outputs the value of the variable, which starts as 0. For example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. This can be useful in cases where you need to know the outcome of an earlier attack, such as whether you've already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6)) + $a"),h(a.Function,"@X",/^@([a-zA-Z0-9]+)$/,(function(e){return{funcName:e[1]}}),(function(e,t){var n;return(null===(n=e.funcReg.get(t.props.funcName))||void 0===n?void 0:n.eval(e))||0}),"Where X is a string of alphanumeric characters. A function that can be assigned a sub expression and then later evaluated. Outputs the result of evaluating the sub expression (any dice rolls will be rerolled each time), or 0 if an expression has not yet been assigned. For example:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each time it is used later, it will be re-evaluated (dice will be rolled again). This can be useful in cases where you want to evaluate the same thing multiple times, like sneak attack after each attack:\n  (@sa := $sd<=0 => ($sd:=1D6)+$sd) + (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @s) + $sd")]},4873:function(e,t,n){function a(e,t,n){if(void 0===t&&(t=e,e=0),void 0===n&&(n=1),n>0&&e>=t||n<0&&e<=t)return[];for(var a=[],r=e;n>0?r<t:r>t;r+=n)a.push(r);return a}n.d(t,{w:function(){return a}})}}]);
//# sourceMappingURL=477.5af00d90.chunk.js.map