{"version":3,"file":"static/js/641.68f64638.chunk.js","mappings":"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","sources":["sim/parse.ts","worker/sim/worker.ts","sim/Simulation.ts","util/Distribution.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import parseRanges from 'util/parseRanges';\nimport Expression from './expressions/Expression';\nimport ExpressionCreator from './expressions/ExpressionCreator';\nimport { SplitExpressions } from './expressions/splitOperatorExpressions';\nimport { UnaryExpressions } from './expressions/unaryOperatorExpressions';\nimport { ValueExpressions } from './expressions/valueExpressions';\nimport SimState from './SimState';\nimport Simulation, { SimulationSource } from './Simulation';\nimport { arrayBinned } from 'util/arrays';\nimport { stripComments, stripCommentsFromLines } from 'util/stripComments';\nimport stripError from 'util/stripError';\nimport { LineError, ParsedSims } from './ParsedSims';\n\nconst OperatorExpressions = [...SplitExpressions, ...UnaryExpressions];\nconst SimDefinitionRegex = /[^:#@]+@[- \\t,\\d]+:(.*)/;\n\nfunction matchAt(matches: RegExpMatchArray[], index: number): RegExpExecArray | null {\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i].index === index) {\n      return matches[i] as RegExpExecArray;\n    }\n  }\n  return null;\n}\n\nfunction appendChunk(result: string[], chunk: string, resets: number) {\n  if (resets === 1 && chunk.startsWith('(') && chunk.endsWith(')')) {\n    chunk = chunk.substring(1, chunk.length - 1);\n  }\n  result.push(chunk);\n}\n\nfunction splitExpr(\n  expr: string, operator: ExpressionCreator<any>,\n): [string[], RegExpExecArray | null, number] {\n  const matches = [...expr.matchAll(operator.globalRegex)];\n  if (!matches.length) {\n    return [[], null, 0];\n  }\n\n  const result: string[] = [];\n  let braces = 0;\n  let currentChunk = '';\n  let chunkParensResets = 0;\n  let opMatch: RegExpExecArray | null = null;\n  let i = 0;\n  while (i < expr.length) {\n    const curChar = expr[i];\n    if (curChar === '(') {\n      braces += 1;\n    } else if (curChar === ')') {\n      braces -= 1;\n      if (braces === 0) {\n        chunkParensResets += 1;\n      }\n    }\n    if (braces === 0 && !opMatch && (operator.numOperands !== 2 || i > 0)) {\n      opMatch = matchAt(matches, i);\n      if (opMatch) {\n        appendChunk(result, currentChunk, chunkParensResets);\n        currentChunk = '';\n        chunkParensResets = 0;\n        i += opMatch[0].length;\n        continue;\n      }\n    }\n    currentChunk += curChar;\n    i += 1;\n  }\n  if (braces !== 0) {\n    throw Error(`Unbalanced parentheses in expression \"${expr}\"`);\n  }\n  appendChunk(result, currentChunk, chunkParensResets);\n  return [result.filter(Boolean), opMatch, chunkParensResets];\n}\n\ntype Source = Pick<SimulationSource, 'definition' | 'lineStart' | 'lineCount'>;\n\nexport function parseSimExpr(rawExpr: string): Expression {\n  for (let exprCreator of OperatorExpressions) {\n    const [parts, opMatch, parensGroups] = splitExpr(rawExpr, exprCreator)\n    if (parts.length === 1 && parensGroups === 1 && rawExpr.startsWith('(') && rawExpr.endsWith(')')) {\n      return parseSimExpr(parts[0]);\n    }\n    if (opMatch && parts.length === exprCreator.numOperands) {\n      return exprCreator.create(rawExpr, parts.map(parseSimExpr), opMatch) as Expression;\n    }\n  }\n\n  for (let exprCreator of ValueExpressions) {\n    const match = exprCreator.regex.exec(rawExpr);\n    if (match) {\n      return exprCreator.create(rawExpr, [], match) as Expression;\n    }\n  }\n\n  throw Error(`Invalid expression: \"${rawExpr}\"`)\n}\n\nexport function parseSimDef(source: Source): Simulation[] {\n  const [nameLevel, expr] = source.definition.trim().split(/:(.*)/s);\n  if (!expr) {\n    throw new Error(`Simulation definition \"${source.definition}\" is not correctly formatted.`)\n  }\n  let levels = [0];\n  let name = nameLevel;\n  if (nameLevel.includes('@')) {\n    const [namePart, levelsPart] = name.split('@');\n    name = namePart;\n    levels = parseRanges([levelsPart]);\n  }\n  let expression: Expression<unknown>;\n  let error: string | undefined;\n  const rawExpr = stripCommentsFromLines(expr).replace(/\\s+/g, '');\n  try {\n    expression = parseSimExpr(rawExpr);\n  } catch (e) {\n    expression = parseSimExpr('0');\n    error = String(e);\n  }\n  const simSource: SimulationSource = {\n    ...source,\n    rawExpression: rawExpr,\n  };\n  return levels.map((level) => {\n    const sim = new Simulation(name, level, simSource, expression);\n    sim.error = error;\n    return sim;\n  });\n}\n\nexport function tryParseTestSimDef(source: Source): Simulation[] {\n  const sims = parseSimDef(source);\n  sims.forEach((sim) => {\n    if (!sim.error) {\n      try {\n        // Perform a test run, to make sure it's all good!\n        sim.run(new SimState({ ac: 10, pb: 2, level: 1, sm: 0 }));\n      } catch (e) {\n        sim.error = String(e);\n      }\n    }\n  });\n  return sims;\n}\n\nexport function parseTestSimDef(source: Source): Simulation[] {\n  const sims = tryParseTestSimDef(source);\n  const firstError = sims.find((s) => s.error)?.error;\n  if (firstError) {\n    throw new Error(firstError);\n  }\n  return sims;\n}\n\nexport function parseSimDefsScript(simDefsScript: string): ParsedSims {\n  const errors: LineError[] = [];\n  const sims: Simulation[] = [];\n  const lines = simDefsScript.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    const lineStart = i;\n    const line = lines[i];\n    if (!stripComments(line).trim()) {\n      continue;\n    }\n    const match = SimDefinitionRegex.exec(line);\n    if (!match) {\n      errors.push({ lineStart, message: 'Invalid name@level: definition' });\n      continue;\n    }\n\n    let simDef = line;\n    if (match[1].includes('(')) {\n      let braces = 0;\n      let j = i;\n      let innerLine = match[1];\n      do {\n        if (!line.trim()) {\n          continue;\n        }\n        if (SimDefinitionRegex.test(innerLine)) {\n          break;\n        }\n        for (let k = 0; k < innerLine.length; k++) {\n          const char = innerLine[k];\n          if (char === '(') {\n            braces += 1;\n          } else if (char === ')') {\n            braces -= 1;\n          }\n        }\n        j += 1;\n        innerLine = lines[j];\n      } while (braces > 0 && j < lines.length);\n      const extraLines = lines.slice(i + 1, j).join('\\n');\n      simDef = `${match[0].trim()}\\n${extraLines}`.trim();\n      i = j - 1;\n    }\n    const lineCount = 1 + i - lineStart;\n\n    try {\n      const parseResults = tryParseTestSimDef({ definition: simDef, lineStart, lineCount });\n      const error = parseResults.find((sim) => sim.error)?.error;\n      if (error) {\n        errors.push({ lineStart, lineCount, message: stripError(error) });\n      } else {\n        sims.push(...parseResults);\n      }\n    } catch (e) {\n      errors.push({ lineStart, lineCount, message: stripError(String(e)) });\n    }\n  }\n  const simsByName = arrayBinned(sims, (sim) => sim.name);\n  return { sims: simsByName, errors, names: Object.keys(simsByName) }\n}\n","import { parseSimExpr } from 'sim/parse';\nimport SimParams from 'sim/SimParams';\nimport SimState from 'sim/SimState';\nimport { BaseSimulation } from 'sim/Simulation';\nimport { MutableDistribution } from 'util/Distribution';\nimport { ToWorkerMessages } from './Messages';\n\n// Each worker will be effectively run in a separate interpreter, so global\n// state isn't actually very global; each worker will have their own copy of\n// the below state\nlet simulation: BaseSimulation | undefined;\nlet simParams: SimParams | undefined;\n\nonmessage = function(event: MessageEvent<ToWorkerMessages>) {\n  const { data } = event;\n  if (data.command === 'configure') {\n    const { expression, config } = data;\n    simulation = new BaseSimulation(expression, parseSimExpr(expression));\n    simParams = config;\n  } else if (data.command === 'run') {\n    const { iterations } = data;\n    const distribution = runSims(iterations);\n    this.postMessage({ command: 'complete', distribution });\n  }\n}\n\nfunction runSims(iterations: number) {\n  if (!simulation || !simParams) throw new Error('Worker is not configured!');\n  const results = new MutableDistribution();\n  const state = new SimState(simParams);\n  for (let i = 0; i < iterations; i++) {\n    state.reset();\n    results.increment(simulation.run(state));\n  }\n  return results.toImmutable();\n}\n\nexport {}\n","import Expression from './expressions/Expression';\nimport SimState from './SimState';\n\nexport interface SimulationSource {\n  definition: string;\n  rawExpression: string;\n  lineStart?: number;\n  lineCount?: number;\n}\n\nexport class BaseSimulation {\n  rawExpression: string;\n  rootExpression: Expression;\n\n  constructor(rawExpr: string, rootExpr: Expression) {\n    this.rawExpression = rawExpr\n    this.rootExpression = rootExpr\n  }\n\n  run(initialState: SimState) {\n    return this.rootExpression.eval(initialState)\n  }\n}\n\nexport default class Simulation extends BaseSimulation {\n  name: string;\n  level: number;\n  source: SimulationSource;\n  error?: string;\n\n  constructor(name: string, level: number, source: SimulationSource, rootExpr: Expression) {\n    super(source.rawExpression, rootExpr);\n    this.name = name;\n    this.level = level;\n    this.source = source;\n    this.error = undefined;\n  }\n  \n  id() {\n    return `${this.name}@${this.level}`;\n  }\n\n  isValid() {\n    return !this.error;\n  }\n}\n","class Distribution {\n  protected map: Map<number, number>;\n  protected sumTotal: number;\n\n  constructor(entries?: [number, number][]) {\n    this.map = new Map(entries);\n    this.sumTotal = (entries || []).reduce((sum, [, count]) => sum + count, 0);\n  }\n\n  /** Returns the number of values (with count > 0) */\n  uniqueCount() {\n    return this.map.size;\n  }\n\n  /** Returns the total sum of counts across all values */\n  totalCount() {\n    return this.sumTotal;\n  }\n\n  entries() {\n    return [...this.map.entries()];\n  }\n\n  uniqueValues() {\n    return [...this.map.keys()];\n  }\n\n  getCount(value: number) {\n    return this.map.get(value) || 0;\n  }\n\n  static merge(...dists: Distribution[]) {\n    const merged = new Distribution();\n    const m = merged.map;\n    dists.forEach((dist) => {\n      dist.map.forEach((c, v) => m.set(v, (m.get(v) || 0) + c));\n      merged.sumTotal += dist.sumTotal;\n    });\n    return merged;\n  }\n}\n\nexport class MutableDistribution extends Distribution {\n  increment(value: number) {\n    this.map.set(value, (this.map.get(value) || 0) + 1);\n    this.sumTotal += 1;\n  }\n\n  toImmutable() {\n    return new Distribution(this.entries());\n  }\n}\n\nexport default Distribution;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [91], function() { return __webpack_require__(4641); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"c1ce93cc\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/dsim/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t641: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdsim\"] = self[\"webpackChunkdsim\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(91).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["OperatorExpressions","SplitExpressions","UnaryExpressions","matchAt","matches","index","i","length","appendChunk","result","chunk","resets","startsWith","endsWith","substring","push","splitExpr","expr","operator","matchAll","globalRegex","braces","currentChunk","chunkParensResets","opMatch","curChar","numOperands","Error","filter","Boolean","parseSimExpr","rawExpr","exprCreator","parts","parensGroups","create","map","ValueExpressions","match","regex","exec","simulation","simParams","BaseSimulation","rootExpr","rawExpression","rootExpression","this","initialState","eval","Distribution","entries","sumTotal","Map","reduce","sum","size","keys","value","get","merged","m","dists","forEach","dist","c","v","set","MutableDistribution","onmessage","event","data","command","expression","config","distribution","iterations","results","state","SimState","reset","increment","run","toImmutable","runSims","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","every","key","splice","r","d","definition","o","defineProperty","enumerable","f","e","chunkId","Promise","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}