{"version":3,"file":"static/js/477.5af00d90.chunk.js","mappings":"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","sources":["sim/SimState.ts","sim/expressions/Expression.ts","sim/expressions/ExpressionCreator.ts","sim/expressions/expressionUtils.ts","sim/expressions/splitOperatorExpressions.ts","sim/expressions/unaryOperatorExpressions.ts","sim/expressions/valueExpressions.ts","util/range.ts"],"sourcesContent":["import Expression from './expressions/Expression';\nimport SimParams from './SimParams';\n\nclass SimState implements SimParams {\n  // Static state\n  readonly ac: number;\n  readonly level: number;\n  readonly pb: number;\n  readonly sm: number;\n\n  // Dynamic state\n  readonly critStack: boolean[];\n  readonly funcReg: Map<string, Expression>;\n  readonly varReg: Map<string, number>;\n\n  constructor(config: SimParams) {\n    this.ac = config.ac;\n    this.sm = config.sm;\n    this.pb = config.pb;\n    this.level = config.level;\n\n    this.varReg = new Map();\n    this.funcReg = new Map();\n    this.critStack = [];\n  }\n\n  crit() {\n    return !!this.critStack[this.critStack.length - 1];\n  }\n\n  popCrit() {\n    this.critStack.pop();\n  }\n\n  pushCrit(newCrit: boolean) {\n    this.critStack.push(newCrit);\n  }\n\n  reset() {\n    this.critStack.length = 0;\n    this.funcReg.clear();\n    this.varReg.clear();\n  }\n}\n\nexport default SimState;\n","import SimState from '../SimState';\n\nexport type EvalFunc<T> = (s: SimState, ctx: Expression<T>) => number;\n\nexport default class Expression<T = unknown> {\n  typeName: string;\n  rawExpression: string;\n  subExpressions: Expression[];\n  evalFunc: EvalFunc<T>;\n  props: T;\n\n  constructor(typeName: string, expr: string, subExprs: Expression[], evalFunc: EvalFunc<T>, props: T) {\n    this.typeName = typeName;\n    this.rawExpression = expr;\n    this.subExpressions = subExprs;\n    this.evalFunc = evalFunc;\n    this.props = props;\n  }\n\n  eval(state: SimState): number {\n    return this.evalFunc(state, this);\n  }\n\n  *iterateExpression(): Generator<Expression> {\n    yield this as Expression;\n    for (const subExpr of this.subExpressions) {\n      yield* subExpr.iterateExpression();\n    }\n  }\n}\n","import Expression, { EvalFunc } from './Expression';\n\nexport type ParseFunc<T> = (match: RegExpExecArray, subExprs: Expression[]) => T;\n\ninterface ExpressionParams<T> {\n  typeName: string;\n  regex: RegExp;\n  numOperands?: number;\n  parseFunc: ParseFunc<T>;\n  evalFunc: EvalFunc<T>;\n  sample: string;\n  description: string;\n}\n\nexport default class ExpressionCreator<T> {\n  typeName: string;\n  regex: RegExp;\n  globalRegex: RegExp;\n  parseFunc: ParseFunc<T>;\n  evalFunc: EvalFunc<T>;\n  numOperands: number; \n  sample: string;\n  description: string;\n\n  constructor(params: ExpressionParams<T>) {\n    this.typeName = params.typeName;\n    this.regex = params.regex;\n    const gFlags = params.regex.flags ? `${params.regex.flags}g` : 'g';\n    this.globalRegex = new RegExp(params.regex.source, gFlags);\n    this.parseFunc = params.parseFunc\n    this.evalFunc = params.evalFunc;\n    this.numOperands = params.numOperands || 0; \n\n    this.sample = params.sample;\n    this.description = params.description;\n  }\n\n  create(expr: string, subExprs: Expression[], match: RegExpExecArray) {\n    if ((this.numOperands && subExprs.length !== this.numOperands)) {\n      throw Error(`Invalid syntax in \"${expr}\": ${this.typeName} expected ${this.numOperands} operands but got ${subExprs.length}`);\n    }\n    const props: T = this.parseFunc(match, subExprs);\n    return new Expression(this.typeName, expr, subExprs, this.evalFunc, props);\n  }\n}\n","const NoPF = () => ({});\n\nlet randomFunction = Math.random;\nconst sum = (values: number[]) => values.reduce((prev, cur) => prev + cur, 0);\nconst roll = (die: number) => Math.floor(randomFunction() * die) + 1;\n\nexport const exportedForTesting = {\n  setRandomFunction: (func: () => number) => randomFunction = func,\n};\n\nconst expressionUtils = { NoPF, sum, roll };\n\nexport default expressionUtils;\n","import { range } from 'util/range';\nimport ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport Expression, { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF, sum, roll } = expressionUtils;\n\nexport enum SplitExpression {\n  Discard = 'Discard',\n  Assign = 'Assign',\n  AssignAndEvaluate = 'Assign (and Evaluate)',\n  // AssignIfNotAlreadyZero = 'Assign If Not Already Zero',\n  // AssignIfAlreadyNonZero = 'Assign If Already Non-Zero',\n  Check = 'Check',\n  Attack = 'Attack',\n  Save = 'Save',\n  Or = 'Or',\n  And = 'And',\n  GreaterThanOrEqualTo = 'Greater Than Or Equal To',\n  GreaterThan = 'Greater Than',\n  LessThanOrEqualTo = 'Less Than Or Equal To',\n  LessThan = 'Less Than',\n  NotEqualTo = 'Not Equal To',\n  EqualTo = 'Equal To',\n  Add = 'Add',\n  Subtract = 'Subtract',\n  Multiply = 'Multiply',\n  Divide = 'Divide',\n  Repeat = 'Repeat',\n  RerollIfLessThanOrEqualTo = 'Reroll (If Less Than Or Equal To)',\n}\n\nfunction splitExpr<T>(\n  typeName: SplitExpression,\n  sample: string,\n  regex: RegExp,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    numOperands: 2,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\nconst checkType = (expr: Expression, type_names: string[]) => {\n  if (!type_names.includes(expr.typeName)) {\n    throw Error(`Type of \"${expr.rawExpression}\" was expected to be one of \"${type_names}\", but was \"${expr.typeName}\"`)\n  }\n  return expr.typeName;\n}\n\nconst parseVantage = (vantage: string, num?: string) => {\n  if (vantage === 'adv') {\n    return Number(num || 2)\n  } else if (vantage === 'dis') {\n    return -Number(num || 2)\n  }\n  return 0;\n};\n\nexport const SplitExpressions = [\n  splitExpr(SplitExpression.Discard, ';', /;/, NoPF,\n    (s, ctx) => { ctx.subExpressions[0].eval(s); return ctx.subExpressions[1].eval(s) },\n    `The result of the left operand is discarded (though is still evaluated, so \\\nvariables and functions will be assigned); output is the result of the \\\nright operand. Can be useful after assignment when the assigned value should \\\nnot be immediately added.`\n  ),\n  splitExpr(SplitExpression.Assign, ':=', /:=/,\n    (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable', 'Function']) }),\n    (s, ctx) => {\n      if (ctx.props.storedType === 'Function') {\n        const funcName = (ctx.subExpressions[0].props as { funcName: string })?.funcName;\n        s.funcReg.set(funcName, ctx.subExpressions[1]);\n      } else if (ctx.props.storedType === 'Variable') {\n        const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n        const value = ctx.subExpressions[1].eval(s);\n        s.varReg.set(varName, value);\n      }\n      return 0;\n    },\n    `Assign value to variable or sub expression to function. Output is 0.\n\nFor example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. \\\nThis can be useful in cases where you need to know the outcome of an earlier \\\nattack, such as whether you've already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6))\n\nCan also assign a sub expression as a function:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each \\\ntime it is used later, it will be re-evaluated (dice will be rolled again):\n  (@a := 1D6+3); (3+PB =atk> @a) + (5+PB =atk> @a)\n\nThese can be combined to useful effect; for example, effects that can only\nhappen once per turn, but have multiple opportunities to happen, like sneak \\\nattack:\n  @sa := !$sd => ($sd=1D6); (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @sa)\nThe above defines a function \"@sa\" (sneak attack) that will roll 1D6, and assign \\\nthe result to \"$sd\" (sneak damage); but only if \"$sd\" is a not (\"!\") zero (i.e. \\\nhas already been rolled). The \";\" separates it from the rest of the expression. \\\nThen \"@sd\" can be inserted anywhere the sneak attack could occur (on any attack \\\nhit). Note that this method will mean that the sneak attack always occurs on \\\nthe first attack that hits.`,\n  ),\n  splitExpr(SplitExpression.AssignAndEvaluate, '=', /(?<![=<>!:&|])=(?![=>a-zA-Z])/,\n    (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable', 'Function']) }),\n    (s, ctx) => {\n      if (ctx.props.storedType === 'Function') {\n        const funcName = (ctx.subExpressions[0].props as { funcName: string })?.funcName;\n        s.funcReg.set(funcName, ctx.subExpressions[1]);\n        return s.funcReg.get(funcName)?.eval(s) || 0;\n      } else if (ctx.props.storedType === 'Variable') {\n        const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n        const value = ctx.subExpressions[1].eval(s);\n        s.varReg.set(varName, value);\n        return value;\n      }\n      return 0;\n    },\n    `Assign value to variable or sub expression to function. Output is the \\\nresult of evaluating the assigned expression. This is the same as \":=\", except \\\nfor the output. NOTE this means that any assigned function will be evaluated\\\nimmediately, and any variables changed as part of the function will be changed \\\nwhen it is immediately evaluated!`,\n  ),\n//   splitExpr(SplitExpression.Assign If Not Already Zero, '|=', /\\|=/,\n//     (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable']) }),\n//     (s, ctx) => {\n//       if (ctx.props.storedType === 'Variable') {\n//         const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n//         const oldValue = s.varReg.get(varName);\n//         if (!oldValue) {\n//           const value = ctx.subExpressions[1].eval(s);\n//           s.varReg.set(varName, value);\n//           return value;\n//         }\n//         return oldValue;\n//       }\n//       return 0;\n//     },\n//     `Assigns to the variable if it is not already set or is set to zero. The \\\n//     following expressions are equivalent:\n//       $a |= 2\n//       $a = $a || 2`,\n//   ),\n//   splitExpr(SplitExpression.Assign If Already Non-Zero, '&=', /&=/,\n//     (m, exprs) => ({ storedType: checkType(exprs[0], ['Variable']) }),\n//     (s, ctx) => {\n//       if (ctx.props.storedType === 'Variable') {\n//         const varName = (ctx.subExpressions[0].props as { varName: string })?.varName;\n//         const oldValue = s.varReg.get(varName);\n//         if (oldValue) {\n//           const value = ctx.subExpressions[1].eval(s);\n//           s.varReg.set(varName, value);\n//           return value;\n//         }\n//         return oldValue || 0;\n//       }\n//       return 0;\n//     },\n//     `Assigns to the variable if it is already set to a non-zero value. The \\\n// following expressions are equivalent:\n//   $a &= 2\n//   $a = $a && 2`,\n//   ),\n  splitExpr(SplitExpression.Check, '=>', /=>/, NoPF, (s, ctx) => {\n    return (ctx.subExpressions[0].eval(s) ? ctx.subExpressions[1].eval(s) : 0);\n  },\n    `If left operand is non-zero, then output the right operand, otherwise \\\noutput 0. For example:\n  (1d20 <= 11) => 1d8`\n  ),\n  splitExpr(SplitExpression.Attack, '=atk>', /=atk(?::(\\d+))?(?::(adv|dis)(\\d+)?)?>/,\n    (m) => ({ critmin: Number(m[1] || 20), vantage: parseVantage(m[2], m[3]) }),\n    (state, { props, subExpressions }) => {\n      let droll = roll(20);\n      if (props.vantage > 1 || props.vantage < -1) {\n        const rolls = range(Math.abs(props.vantage) - 1).map(() => roll(20));\n        const reducer = props.vantage > 0 ? Math.max : Math.min;\n        droll = reducer(droll, ...rolls);\n      }\n      const critMiss = droll === 1;\n      const critHit = droll >= props.critmin;\n      if (!critMiss && (critHit || (subExpressions[0].eval(state) + droll >= state.ac))) {\n        state.pushCrit(critHit);\n        const result = subExpressions[1].eval(state);\n        state.popCrit();\n        return result;\n      }\n      return 0;\n    },\n    `Make an attack. The left operand will be added to the d20 roll, and if \\\nthe result meets the AC then the output is the right operand. For example:\n  3+PB =atk> 1D6+3\nThe above is mostly equivalent to:\n  (3+PB + 1d20 >= AC) => 1D6+3\nHowever, the =atk> operator also accounts for crits. If the d20 rolled for the \\\nattack is a 1, then the attack will miss regardless of modifiers and AC. If the \\\nd20 rolled for the attack is a 20, then the critical hit flag is set (the \\\nnumber of dice rolled in the 1D6 damage roll will then be doubled; note that \\\nthe doubling of dice only applies when the uppercase D is used; using a \\\nlowercase d will not double dice).\n\nCan also specify that the attack be made with advantage or disadvantage:\n  3+PB =atk:adv> 1D6+3\n  3+PB =atk:dis> 1D6+3\nOr even super advantage or disadvantage:\n  3+PB =atk:adv3> 1D6+3\n  3+PB =atk:dis3> 1D6+3\n\nCan also specify the minimum critical hit threshold, for example if you can \\\ncrit on a 19:\n  3+PB =atk:19> 1D6+3\n\nNote that if you specify both adv/dis and crit threshold, the crit threshold \\\nshould come first:\n3+PB =atk:19:dis> 1D6+3`,\n  ),\n  splitExpr(SplitExpression.Save, '=sav>', /=sav:(\\d+)(?::(adv|dis))?>/,\n    (m) => ({ successmod: (Number(m[1] ?? 50) / 100.0), vantage: m[2] }),\n    (state, ctx) => {\n      let droll = roll(20);\n      if (ctx.props.vantage === 'adv') {\n        droll = Math.max(droll, roll(20));\n      } else if (ctx.props.vantage === 'dis') {\n        droll = Math.min(droll, roll(20));\n      }\n\n      const dmg = ctx.subExpressions[1].eval(state)\n      if (droll + state.sm >= ctx.subExpressions[0].eval(state)) {\n        return Math.floor(dmg * ctx.props.successmod);\n      }\n      return dmg;\n    },\n    `Have the target make a saving throw. The left operand is the difficulty \\\nclass (DC) of the save; if the target save (1d20 + SM) does not meet the DC, \\\nthen the output will be the right operand. Otherwise, if the target save does \\\nmeet the DC, then the output will be half the right operand. For example:\n  8+3+PB =sav> 3d8\nThe above is equivalent to:\n  ($s := 1d20 + SM) + ($s < 8+3+PB => 3d8) + ($s >= 8+3+PB => 3d8/2)\n\nCan also specify that the save be made with advantage or disadvantage:\n  8+3+PB =sav:adv> 3d8\n  8+3+PB =sav:dis> 3d8\n\nCan also specify the output modifier for save success, for example if suceeding \\\non the save results in no damage being taken:\n  8+3+PB =sav:0> 3d8\nNote the the success modifier is specified as a positive integer percentage, so \\\na value of 25 would mean that the damage is quartered.\n\nNote that if you specify both adv/dis and success modifier, the success modifier \\\nshould come first:\n  8+3+PB =sav:0:adv> 3d8`,\n  ),\n  splitExpr(SplitExpression.Or, '||', /\\|\\|/, NoPF,\n    (s, ctx) => ctx.subExpressions[0].eval(s) || ctx.subExpressions[1].eval(s),\n    'Outputs the second operand if the first is 0, otherwise outputs the first operand.',\n  ),\n  splitExpr(SplitExpression.And, '&&', /&&/, NoPF,\n    (s, ctx) => ctx.subExpressions[0].eval(s) && ctx.subExpressions[1].eval(s),\n    'Outputs the second operand if the first is non-zero, otherwise outputs 0',\n  ),\n  splitExpr(SplitExpression.GreaterThanOrEqualTo, '>=', />=/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) >= ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is greater than or equal to the right operand, otherwise 0.',\n  ),\n  splitExpr(SplitExpression.GreaterThan, '>', /(?<!=)>(?!=)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) > ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is greater than the right operand, otherwise 0.',\n  ),\n  splitExpr(SplitExpression.LessThanOrEqualTo, '<=', /<=/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) <= ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is less than or equal to the right operand, otherwise 0.',\n  ),\n  splitExpr(SplitExpression.LessThan, '<', /(?<!=)<(?!=)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) < ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is less than the right operand, otherwise 0.',\n  ),\n  splitExpr(SplitExpression.NotEqualTo, '!=', /!=(?!>)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) !== ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is not equal to the right operand, otherwise 0.',\n  ),\n  splitExpr(SplitExpression.EqualTo, '==', /==(?!>)/, NoPF,\n    (s, ctx) => Number(ctx.subExpressions[0].eval(s) === ctx.subExpressions[1].eval(s)),\n    'Outputs 1 if the left operand is equal to the right operand, otherwise 0.',\n  ),\n  splitExpr(SplitExpression.Add, '+', /\\+/, NoPF,\n    (s, ctx) => sum(ctx.subExpressions.map((e) => e.eval(s))),\n    'Outputs the sum of the left operand and right operand',\n  ),\n  splitExpr(SplitExpression.Subtract, '-', /(?<![-+*/=><|&])-(?!>)/, NoPF,\n    (s, ctx) => ctx.subExpressions[0].eval(s) - sum(ctx.subExpressions.slice(1).map((e) => e.eval(s))),\n    'Outputs the result of subtracting the right operand from the left operand.',\n  ),\n  splitExpr(SplitExpression.Multiply, '*', /\\*/, NoPF,\n    (s, ctx) => ctx.subExpressions.reduce((a, e) => a * e.eval(s), 1),\n    'Outputs the result of multiplying the left operand by the right operand.',\n  ),\n  splitExpr(SplitExpression.Divide, '/', /\\//, NoPF,\n    (s, ctx) => Math.floor(ctx.subExpressions[0].eval(s) / ctx.subExpressions[1].eval(s)),\n    `Outputs the result of dividing the left operand by the right operand. \\\nDecimal results are rounded down the nearest whole integer.`,\n  ),\n  splitExpr(SplitExpression.Repeat, '#', /#/, NoPF, \n    (s, ctx) => {\n      const num = Number(ctx.subExpressions[0].eval(s));\n      if (num < 0) {\n        throw new Error(`Cannot repeat a negative (${num}) number of times: ${ctx.rawExpression}`);\n      }\n      return sum([...new Array(num)].map(() => ctx.subExpressions[1].eval(s)))\n    },\n    `Outputs the sum of repeating evaluation of the right operand a number of \\\ntimes equal to the left operand. Left operand must be a positive integer.`,\n  ),\n  // TODO: Remove this at some point\n  splitExpr(SplitExpression.RerollIfLessThanOrEqualTo, '@rrlte:', /@rrlte:/,\n    (): {} => { throw new Error('@rrlte: has been removed; use the 2d6rrle2 syntax instead') },\n    () => { throw new Error('@rrlte: has been removed; use the 2d6rrle2 syntax instead') },\n    '',\n  ),\n];\n","import ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF } = expressionUtils;\n\nfunction unaryExpr<T>(\n  typeName: string,\n  sample: string,\n  regex: RegExp,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    numOperands: 1,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\nexport const UnaryExpressions = [\n  unaryExpr('Not', '!', /^!/, NoPF,\n    (s, ctx) => (ctx.subExpressions[0].eval(s) ? 0 : 1),\n    'Outputs 0 if the right operand is non-zero, otherwise outputs 1.',\n  ),\n  unaryExpr('Negative', '-', /^-/, NoPF,\n    (s, ctx) => (ctx.subExpressions[0].eval(s) * -1),\n    'Flips the sign of the right operand (multiply by -1).',\n  ),\n];\n","import ExpressionCreator, { ParseFunc } from './ExpressionCreator';\nimport { EvalFunc } from './Expression';\nimport expressionUtils from './expressionUtils';\n\nconst { NoPF, sum, roll } = expressionUtils;\n\nexport enum ValueExpression {\n  Number = 'Number',\n  RollDice = 'Roll Dice',\n  ArmorClass = 'Armor Class',\n  SaveModifier = 'Save Modifier',\n  ProficiencyBonus = 'Proficiency Bonus',\n  Level = 'Level',\n  CriticalMultiplier = 'Critical Multiplier',\n  CriticalBinary = 'Critical Binary',\n  Variable = 'Variable',\n  Function = 'Function',\n}\n\nfunction valueExpr<T>(\n  typeName: ValueExpression,\n  sample: string,\n  regex: RegExp,\n  parseFunc: ParseFunc<T>,\n  evalFunc: EvalFunc<T>,\n  description: string,\n) {\n  return new ExpressionCreator({\n    typeName,\n    regex,\n    parseFunc,\n    evalFunc,\n    description,\n    sample\n  });\n}\n\ntype RollOp = (rolls: number[], param: number, dieSize: number) => number[] | void;\nconst rollOperations: Record<string, RollOp> = {\n  kh: (rolls, param) => rolls.sort((a, b) => (b - a)).slice(0, param),\n  kl: (rolls, param) => rolls.sort((a, b) => (a - b)).slice(0, param),\n  rrle: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v <= param) a[i] = roll(ds); }),\n  rrlt: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v < param) a[i] = roll(ds); }),\n  rrge: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v >= param) a[i] = roll(ds); }),\n  rrgt: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v > param) a[i] = roll(ds); }),\n  rreq: (rolls, param, ds) => rolls.forEach((v, i, a) => { if (v === param) a[i] = roll(ds); }),\n};\nconst rollOpRegex = Object.keys(rollOperations).join('|');\n\nexport const ValueExpressions = [\n  valueExpr(ValueExpression.Number, 'X', /^\\d+$/, (m) => ({ value: Number(m[0]) }), (s, { props }) => props.value,\n  'Where X is any positive integer. Outputs the value of the integer.',\n  ),\n  valueExpr(ValueExpression.RollDice, 'XdY', new RegExp(`^(\\\\d*)([dD])(\\\\d+)((?:(?:${rollOpRegex})\\\\d+)*)$`),\n    (m) => {\n      return ({\n        crittable: m[2] === 'D',\n        dieSize: Number(m[3]),\n        numDice: Number(m[1] || 1),\n        operations: [...m[4].matchAll(/([a-zA-Z]+)(\\d+)/g)].map((om) => ({\n          operation: om[1],\n          param: Number(om[2]),\n        })),\n      });\n    },\n    (s, { props }) => {\n      const { crittable, dieSize, numDice, operations } = props;\n      let rolls: number[] = [];\n      const numWithCrit = (crittable && s.crit()) ? 2 * numDice : numDice;\n      for (let i = 0; i < numWithCrit; i += 1) {\n        rolls.push(roll(dieSize));\n      }\n      operations.forEach(({ operation, param }) => {\n        rolls = rollOperations[operation](rolls, param, dieSize) || rolls;\n      });\n      return sum(rolls);\n    },\n    `Where X and Y are any positive integers. Outputs the sum of rolls with a \\\ndice of size Y rolled X number of times. For example:\n  3d8\nIn the above, an 8 sided dice will be rolled 3 times, and the output will be \\\nthe sum of the results.\n\nCritical hits can be accounted for with an uppercase D to double the number of \\\ndice rolled on a critical hit:\n  3D8\nIn the above, if the critical hit flag is set  (in the right operand of an \\\nAttack where the attack roll was >= to the critical threshold), then an 8 sided \\\ndice will be rolled 6 times.\n\nCan also append additional modifier operations after the above basic rolls, \\\nsuch as \"keep highest\":\n  3d8kh2\nThe above rolls 3 d8s, and keeps the two highest rolls. To simulate the \"Great \\\nWeapon Fighting Style\" you could instead use rrle:\n  2D6rrle2\nWhich rolls 2 d6s (or 4 on a crit), and rerolls any 1s and 2s. Any number of \\\nthese operations can be appended, such as:\n  4d6kl2rrle2kh1\nWhich rolls 4 d6s, then keeps the lowest 2, then rerolls any of the remaining 2 \\\nthat are 2 or less, then keeps the highest 1 of those remaining 2.\n\nThe available modifier operations (where X is any positive integer) are:\n  khX: Keep the highest X dice\n  klX: Keep the lowest X dice\n  rrleX: Reroll (only once) any dice that are less than or equal to X\n  rrltX: Reroll (only once) any dice that are less than X\n  rrgeX: Reroll (only once) any dice that are greater than or equal to X\n  rrgtX: Reroll (only once) any dice that are greater than X\n  rreqX: Reroll (only once) any dice that are equal to X\n`\n  ),\n  valueExpr(ValueExpression.ArmorClass, 'AC', /^AC$/, NoPF, (s, ctx) => s.ac,\n    'Outputs the armor class of the target the simulation is being run against.'\n  ),\n  valueExpr(ValueExpression.SaveModifier, 'SM', /^SM$/, NoPF, (s, ctx) => s.ac,\n    'Outputs the save modifier of the target the simulation is being run against.'\n  ),\n  valueExpr(ValueExpression.ProficiencyBonus, 'PB', /^PB$/, NoPF, (s, ctx) => s.pb,\n    'Outputs the proficiency bonus for the level of the character build.'\n  ),\n  valueExpr(ValueExpression.Level, 'LV', /^LV$/, NoPF, (s, ctx) => s.level,\n    'Outputs the level of the character build.'\n  ),\n  valueExpr(ValueExpression.CriticalMultiplier, 'CM', /^CM$/, NoPF, (s, ctx) => Number(s.crit()) * 1 + 1,\n    `Outputs 2 if critical flag is set (in the right operand of an Attack where \\\n  the attack roll was >= to the critical threshold), otherwise 1.`\n  ),\n  valueExpr(ValueExpression.CriticalBinary, 'CB', /^CB$/, NoPF, (s, ctx) => Number(s.crit()) * 1,\n    `Outputs 1 if critical flag is set (in the right operand of an Attack where \\\nthe attack roll was >= to the critical threshold), otherwise 0.`\n  ),\n  valueExpr(ValueExpression.Variable, '$X', /^\\$([a-zA-Z0-9]+)$/,\n    (m) => ({ varName: m[1] }),\n    (s, ctx) => s.varReg.get(ctx.props.varName) || 0,\n    `Where X is a string of alphanumeric characters. A variable that can be \\\nstored and retrieved. Outputs the value of the variable, which starts as 0. \\\nFor example:\n  $a := 1d6\nIn the above, the outcome of the 1d6 roll will be assigned to $a for later use. \\\nThis can be useful in cases where you need to know the outcome of an earlier \\\nattack, such as whether you've already used your sneak attack for the turn:\n  ($a := (3+PB =atk> 1D6+3 + 1D6)) + (3+PB =atk> 1D6 + ($a<=0 => 1D6)) + $a`,\n  ),\n  valueExpr(ValueExpression.Function, '@X', /^@([a-zA-Z0-9]+)$/,\n    (m) => ({ funcName: m[1] }),\n    (s, ctx) => s.funcReg.get(ctx.props.funcName)?.eval(s) || 0,\n    `Where X is a string of alphanumeric characters. A function that can be \\\nassigned a sub expression and then later evaluated. \\\nOutputs the result of evaluating the sub expression (any dice rolls will be \\\nrerolled each time), or 0 if an expression has not yet been assigned. For \\\nexample:\n  @a := 3+PB =atk> 1D6+3\nIn the above, the attack sub expression is assigned to $a for later use. Each \\\ntime it is used later, it will be re-evaluated (dice will be rolled again). \\\nThis can be useful in cases where you want to evaluate the same thing multiple \\\ntimes, like sneak attack after each attack:\n  (@sa := $sd<=0 => ($sd:=1D6)+$sd) + (3+PB =atk> 1D6+3 + @sa) + (3+PB =atk> 1D6 + @s) + $sd`,\n  ),\n];\n","\nexport function range(stop: number): number[];\nexport function range(start: number, stop: number): number[];\nexport function range(start: number, stop: number, step: number): number[];\nexport function range(start: number, stop?: number, step?: number): number[] {\n  if (stop === undefined) {\n      // one param defined\n      stop = start;\n      start = 0;\n  }\n\n  if (step === undefined) {\n      step = 1;\n  }\n\n  if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n      return [];\n  }\n\n  var result = [];\n  for (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n      result.push(i);\n  }\n\n  return result;\n};\n"],"names":["SimState","config","ac","level","pb","sm","critStack","funcReg","varReg","this","Map","length","pop","newCrit","push","clear","Expression","typeName","expr","subExprs","evalFunc","props","rawExpression","subExpressions","state","subExpr","iterateExpression","ExpressionCreator","params","regex","globalRegex","parseFunc","numOperands","sample","description","gFlags","flags","RegExp","source","match","Error","randomFunction","Math","random","expressionUtils","NoPF","sum","values","reduce","prev","cur","roll","die","floor","SplitExpression","splitExpr","checkType","type_names","includes","SplitExpressions","Discard","s","ctx","eval","Assign","m","exprs","storedType","funcName","set","varName","value","AssignAndEvaluate","get","Check","Attack","critmin","Number","vantage","num","droll","rolls","range","abs","map","max","min","critMiss","critHit","pushCrit","result","popCrit","Save","successmod","dmg","Or","And","GreaterThanOrEqualTo","GreaterThan","LessThanOrEqualTo","LessThan","NotEqualTo","EqualTo","Add","e","Subtract","slice","Multiply","a","Divide","Repeat","Array","RerollIfLessThanOrEqualTo","unaryExpr","UnaryExpressions","ValueExpression","valueExpr","rollOperations","kh","param","sort","b","kl","rrle","ds","forEach","v","i","rrlt","rrge","rrgt","rreq","rollOpRegex","Object","keys","join","ValueExpressions","RollDice","crittable","dieSize","numDice","operations","matchAll","om","operation","numWithCrit","crit","ArmorClass","SaveModifier","ProficiencyBonus","Level","CriticalMultiplier","CriticalBinary","Variable","Function","start","stop","step","undefined"],"sourceRoot":""}